"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DependencyWheelPoint from"./DependencyWheelPoint.js";import DependencyWheelSeriesDefaults from"./DependencyWheelSeriesDefaults.js";import H from"../../Core/Globals.js";const deg2rad=H["deg2rad"];import SankeyColumnComposition from"../Sankey/SankeyColumnComposition.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries,sankey:SankeySeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{extend,merge,relativeLength}=U;class DependencyWheelSeries extends SankeySeries{animate(e){var t=this;if(!e){const o=animObject(t.options.animation).duration,n=o/2/t.nodes.length;let e=0;for(const i of t.nodes){const s=i.graphic;s&&(s.attr({opacity:0}),setTimeout(()=>{i.graphic&&i.graphic.animate({opacity:1},{duration:n})},n*e++))}for(const r of t.points){const a=r.graphic;!r.isNode&&a&&a.attr({opacity:0}).animate({opacity:1},t.options.animation)}}}createNode(e){const r=super.createNode(e);return r.getSum=()=>r.linksFrom.concat(r.linksTo).reduce((e,t)=>e+t.weight,0),r.offset=t=>{const o=e=>e.fromNode===r?e.toNode:e.fromNode;let n=0,i=r.linksFrom.concat(r.linksTo),s;i.sort((e,t)=>o(e).index-o(t).index);for(let e=0;e<i.length;e++)if(o(i[e]).index>r.index){i=i.slice(0,e).reverse().concat(i.slice(e).reverse()),s=!0;break}s||i.reverse();for(let e=0;e<i.length;e++){if(i[e]===t)return n;n+=i[e].weight}},r}createNodeColumns(){const e=[SankeyColumnComposition.compose([],this)];for(const t of this.nodes)t.column=0,e[0].push(t);return e}getNodePadding(){return this.options.nodePadding/Math.PI}translate(){const e=this,r=e.options,a=2*Math.PI/(e.chart.plotHeight+e.getNodePadding()),t=e.getCenter(),c=(r.startAngle-90)*deg2rad,o=r.borderRadius,n="object"==typeof o?o.radius:o;super.translate();for(const i of this.nodeColumns[0])if(i.sum){const s=i.shapeArgs,d=t[0],l=t[1],h=t[2]/2,y="auto"===r.nodeWidth?20:r.nodeWidth,m=h-relativeLength(y||0,h),g=c+a*(s.y||0),f=c+a*((s.y||0)+(s.height||0));i.angle=g+(f-g)/2,i.shapeType="arc",i.shapeArgs={x:d,y:l,r:h,innerR:m,start:g,end:f,borderRadius:n},i.dlBox={x:d+Math.cos((g+f)/2)*(h+m)/2,y:l+Math.sin((g+f)/2)*(h+m)/2,width:1,height:1};for(const u of i.linksFrom)if(u.linkBase){let i,s;var p=u.linkBase.map((e,t)=>{var e=a*e,o=Math.cos(c+e)*(1+m),n=Math.sin(c+e)*(1+m);return i=r.curveFactor||0,(s=Math.abs(u.linkBase[3-t]*a-e))>Math.PI&&(s=2*Math.PI-s),(s*=m)<m&&(i*=s/m),{x:d+o,y:l+n,cpX:d+(1-i)*o,cpY:l+(1-i)*n}});u.shapeArgs={d:[["M",p[0].x,p[0].y],["A",m,m,0,0,1,p[1].x,p[1].y],["C",p[1].cpX,p[1].cpY,p[2].cpX,p[2].cpY,p[2].x,p[2].y],["A",m,m,0,0,1,p[3].x,p[3].y],["C",p[3].cpX,p[3].cpY,p[0].cpX,p[0].cpY,p[0].x,p[0].y]]}}}}}DependencyWheelSeries.defaultOptions=merge(SankeySeries.defaultOptions,DependencyWheelSeriesDefaults),extend(DependencyWheelSeries.prototype,{orderNodes:!1,getCenter:PieSeries.prototype.getCenter}),DependencyWheelSeries.prototype.pointClass=DependencyWheelPoint,SeriesRegistry.registerSeriesType("dependencywheel",DependencyWheelSeries);export default DependencyWheelSeries;