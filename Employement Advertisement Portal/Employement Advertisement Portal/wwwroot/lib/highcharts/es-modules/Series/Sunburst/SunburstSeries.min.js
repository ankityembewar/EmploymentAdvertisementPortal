"use strict";import CU from"../CenteredUtilities.js";const{getCenter,getStartAndEndRadians}=CU;import H from"../../Core/Globals.js";const noop=H["noop"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,treemap:TreemapSeries}=SeriesRegistry.seriesTypes;import SunburstPoint from"./SunburstPoint.js";import SunburstUtilities from"./SunburstUtilities.js";import TU from"../TreeUtilities.js";const{getColor,getLevelOptions,setTreeValues,updateRootId}=TU;import U from"../../Core/Utilities.js";import SunburstNode from"./SunburstNode.js";import SunburstSeriesDefaults from"./SunburstSeriesDefaults.js";const{defined,error,extend,fireEvent,isNumber,isObject,isString,merge,splat}=U,rad2deg=180/Math.PI;function isBoolean(e){return"boolean"==typeof e}const getEndPoint=function(e,t,r,s){return{x:e+Math.cos(r)*s,y:t+Math.sin(r)*s}};function getDlOptions(e){const t=e.point,r=isObject(e.shapeArgs)?e.shapeArgs:{},s=isObject(e.optionsPoint)?e.optionsPoint.dataLabels:{},i=splat(isObject(e.level)?e.level.dataLabels:{})[0],o=merge({style:{}},i,s);let n,a,l=o.rotationMode;return isNumber(o.rotation)||("auto"!==l&&"circular"!==l||(o.useHTML&&"circular"===l&&(l="auto"),t.innerArcLength<1&&t.outerArcLength>r.radius?(n=0,t.dataLabelPath&&"circular"===l&&(o.textPath={enabled:!0})):1<t.innerArcLength&&t.outerArcLength>1.5*r.radius?"circular"===l?o.textPath={enabled:!0,attributes:{dy:5}}:l="parallel":(t.dataLabel&&t.dataLabel.textPath&&"circular"===l&&(o.textPath={enabled:!1}),l="perpendicular")),"auto"!==l&&"circular"!==l&&(t.dataLabel&&t.dataLabel.textPath&&(o.textPath={enabled:!1}),n=r.end-(r.end-r.start)/2),"parallel"===l?o.style.width=Math.min(2.5*r.radius,(t.outerArcLength+t.innerArcLength)/2):!defined(o.style.width)&&r.radius&&(o.style.width=1===t.node.level?2*r.radius:r.radius),"perpendicular"===l&&t.outerArcLength<16&&(o.style.width=1),o.style.width=Math.max(o.style.width-2*(o.padding||0),1),a=n*rad2deg%180,"parallel"===l&&(a-=90),90<a?a-=180:a<-90&&(a+=180),o.rotation=a),o.textPath&&(0===t.shapeExisting.innerR&&o.textPath.enabled?(o.rotation=0,o.textPath.enabled=!1,o.style.width=Math.max(2*t.shapeExisting.r-2*(o.padding||0),1)):t.dlOptions&&t.dlOptions.textPath&&!t.dlOptions.textPath.enabled&&"circular"===l&&(o.textPath.enabled=!0),o.textPath.enabled&&(o.rotation=0,o.style.width=Math.max((t.outerArcLength+t.innerArcLength)/2-2*(o.padding||0),1))),o}function getAnimation(e,t){var r=t.point,s=t.radians,i=t.innerR,o=t.idRoot,n=t.idPreviousRoot,a=t.shapeExisting,l=t.shapeRoot,d=t.shapePreviousRoot,t=t.visible;let p={},u={end:e.end,start:e.start,innerR:e.innerR,r:e.r,x:e.x,y:e.y};return t?!r.graphic&&d&&((p=o===r.id?{start:s.start,end:s.end}:d.end<=e.start?{start:s.end,end:s.end}:{start:s.start,end:s.start}).innerR=p.r=i):r.graphic&&(n===r.id?u={innerR:i,r:i}:l&&(u=l.end<=a.start?{innerR:i,r:i,start:s.end,end:s.end}:{innerR:i,r:i,start:s.start,end:s.start})),{from:p,to:u}}function getDrillId(e,t,r){var s=e.node;let i;return i=s.isLeaf?i:t===e.id?r[t].parent:e.id}function cbSetTreeValuesBefore(e,t){const r=t.mapIdToNode,s=e.parent,i=s?r[s]:void 0,o=t.series,n=o.chart,a=o.points,l=a[e.i],d=o.options.colors||n&&n.options.colors,p=getColor(e,{colors:d,colorIndex:o.colorIndex,index:t.index,mapOptionsToLevel:t.mapOptionsToLevel,parentColor:i&&i.color,parentColorIndex:i&&i.colorIndex,series:t.series,siblings:t.siblings});return e.color=p.color,e.colorIndex=p.colorIndex,l&&(l.color=e.color,l.colorIndex=e.colorIndex,e.sliced=e.id!==t.idRoot&&l.sliced),e}class SunburstSeries extends TreemapSeries{alignDataLabel(e,t,r){if(!r.textPath||!r.textPath.enabled)return super.alignDataLabel.apply(this,arguments)}animate(e){const t=this.chart,r=[t.plotWidth/2,t.plotHeight/2],s=t.plotLeft,i=t.plotTop,o=this.group;let n;e?(n={translateX:r[0]+s,translateY:r[1]+i,scaleX:.001,scaleY:.001,rotation:10,opacity:.01},o.attr(n)):(n={translateX:s,translateY:i,scaleX:1,scaleY:1,rotation:0,opacity:1},o.animate(n,this.options.animation))}drawPoints(){const r=this,s=r.mapOptionsToLevel,i=r.shapeRoot,o=r.group,n=r.hasRendered,a=r.rootNode,l=r.idPreviousRoot,d=r.nodeMap,e=d[l],p=e&&e.shapeArgs,t=r.points,u=r.startAndEndRadians,c=r.chart,h=c&&c.options&&c.options.chart||{},g=!isBoolean(h.animation)||h.animation,b=r.center,m={x:b[0],y:b[1]},v=b[3]/2,f=r.chart.renderer,S=!!(g&&n&&a!==l&&r.dataLabelsGroup);let x,R=!1,y=!1;S&&(r.dataLabelsGroup.attr({opacity:0}),x=function(){const e=r;R=!0,e.dataLabelsGroup&&e.dataLabelsGroup.animate({opacity:1,visibility:"inherit"})});for(const L of t){const A=L.node,P=s[A.level],T=L.shapeExisting||{},C=A.shapeArgs||{},O=!(!A.visible||!A.shapeArgs);let e,t;C.borderRadius=r.options.borderRadius,e=n&&g?getAnimation(C,{center:m,point:L,radians:u,innerR:v,idRoot:a,idPreviousRoot:l,shapeExisting:T,shapeRoot:i,shapePreviousRoot:p,visible:O}):{to:C,from:{}},extend(L,{shapeExisting:C,tooltipPos:[C.plotX,C.plotY],drillId:getDrillId(L,a,d),name:""+(L.name||L.id||L.index),plotX:C.plotX,plotY:C.plotY,value:A.val,isInside:O,isNull:!O}),L.dlOptions=getDlOptions({point:L,level:P,optionsPoint:L.options,shapeArgs:C}),!y&&O&&(y=!0,t=x),L.draw({animatableAttribs:e.to,attribs:extend(e.from,!c.styledMode&&r.pointAttribs(L,L.selected&&"select")),onComplete:t,group:o,renderer:f,shapeType:"arc",shapeArgs:C})}S&&y?(r.hasRendered=!1,r.options.dataLabels.defer=!0,ColumnSeries.prototype.drawDataLabels.call(r),r.hasRendered=!0,R&&x()):ColumnSeries.prototype.drawDataLabels.call(r),r.idPreviousRoot=a}layoutAlgorithm(e,t,r){let i=e.start;const o=e.end-i,n=e.val,a=e.x,l=e.y,d=r&&isObject(r.levelSize)&&isNumber(r.levelSize.value)?r.levelSize.value:0,p=e.r,u=p+d,c=r&&isNumber(r.slicedOffset)?r.slicedOffset:0;return(t||[]).reduce((e,t)=>{var r=1/n*t.val*o,s=i+r/2,s=getEndPoint(a,l,s,c),t={x:t.sliced?s.x:a,y:t.sliced?s.y:l,innerR:p,r:u,radius:d,start:i,end:i+r};return e.push(t),i=t.end,e},[])}setRootNode(e,t,r){if(1===this.nodeMap[e].level&&1===this.nodeList.filter(e=>1===e.level).length){if(""===this.idPreviousRoot)return;e=""}super.setRootNode(e,t,r)}setShapeArgs(e,t,r){var s=r[e.level+1],e=e.children.filter(function(e){return e.visible}),i=this.layoutAlgorithm(t,e,s);let o=-1;for(const p of e){var n=i[++o],a=n.start+(n.end-n.start)/2,l=n.innerR+(n.r-n.innerR)/2,d=n.end-n.start,a=0===n.innerR&&6.28<d?{x:n.x,y:n.y}:getEndPoint(n.x,n.y,a,l),l=!p.val||p.childrenTotal>p.val?p.childrenTotal:p.val;this.points[p.i]&&(this.points[p.i].innerArcLength=d*n.innerR,this.points[p.i].outerArcLength=d*n.r),p.shapeArgs=merge(n,{plotX:a.x,plotY:a.y}),p.values=merge(n,{val:l}),p.children.length&&this.setShapeArgs(p,p.values,r)}}translate(){var e=this,t=e.options,r=e.center=e.getCenter(),s=e.startAndEndRadians=getStartAndEndRadians(t.startAngle,t.endAngle),i=r[3]/2,o=r[2]/2-i,n=updateRootId(e);let a=e.nodeMap,l,d=a&&a[n],p={};e.shapeRoot=d&&d.shapeArgs,e.processedXData||e.processData(),e.generatePoints(),fireEvent(e,"afterTranslate");var u=e.tree=e.getTree(),c=(a=e.nodeMap,d=a[n],isString(d.parent)?d.parent:""),c=a[c],{from:h,to:g}=SunburstUtilities.getLevelFromAndTo(d),o=(l=getLevelOptions({from:h,levels:e.options.levels,to:g,defaults:{colorByPoint:t.colorByPoint,dataLabels:t.dataLabels,levelIsConstant:t.levelIsConstant,levelSize:t.levelSize,slicedOffset:t.slicedOffset}}),l=SunburstUtilities.calculateLevelSizes(l,{diffRadius:o,from:h,to:g}),setTreeValues(u,{before:cbSetTreeValuesBefore,idRoot:n,levelIsConstant:t.levelIsConstant,mapOptionsToLevel:l,mapIdToNode:a,points:e.points,series:e}),a[""].shapeArgs={end:s.end,r:i,start:s.start,val:d.val,x:r[0],y:r[1]});this.setShapeArgs(c,o,l),e.mapOptionsToLevel=l;for(const b of e.points)p[b.id]&&error(31,!1,e.chart),p[b.id]=!0;p={}}}SunburstSeries.defaultOptions=merge(TreemapSeries.defaultOptions,SunburstSeriesDefaults),extend(SunburstSeries.prototype,{axisTypes:[],drawDataLabels:noop,getCenter:getCenter,isCartesian:!1,onPointSupported:!0,pointAttribs:ColumnSeries.prototype.pointAttribs,pointClass:SunburstPoint,NodeClass:SunburstNode,utils:SunburstUtilities}),SeriesRegistry.registerSeriesType("sunburst",SunburstSeries);export default SunburstSeries;