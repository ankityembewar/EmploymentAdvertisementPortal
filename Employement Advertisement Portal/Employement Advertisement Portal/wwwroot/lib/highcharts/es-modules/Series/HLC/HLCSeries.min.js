"use strict";import HLCPoint from"./HLCPoint.js";import HLCSeriesDefaults from"./HLCSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ColumnSeries=SeriesRegistry.seriesTypes["column"];import U from"../../Core/Utilities.js";const{extend,merge}=U;class HLCSeries extends ColumnSeries{extendStem(t,e,o){const s=t[0],i=t[1];"number"==typeof s[2]&&(s[2]=Math.max(o+e,s[2])),"number"==typeof i[2]&&(i[2]=Math.min(o-e,i[2]))}getPointPath(t,e){const o=e.strokeWidth(),s=t.series,i=o%2/2,r=Math.round(t.plotX)-i,n=Math.round(t.shapeArgs.width/2);t.plotClose;const a=[["M",r,Math.round(t.yBottom)],["L",r,Math.round(t.plotHigh)]];return null!==t.close&&(e=Math.round(t.plotClose)+i,a.push(["M",r,e],["L",r+n,e]),s.extendStem(a,o/2,e)),a}drawSinglePoint(t){const e=t.series,o=e.chart;let s,i=t.graphic;void 0!==t.plotY&&(i||(t.graphic=i=o.renderer.path().add(e.group)),o.styledMode||i.attr(e.pointAttribs(t,t.selected&&"select")),s=e.getPointPath(t,i),i[i?"animate":"attr"]({d:s}).addClass(t.getClassName(),!0))}drawPoints(){this.points.forEach(this.drawSinglePoint)}init(){super.init.apply(this,arguments),this.options.stacking=void 0}pointAttribs(t,e){const o=super.pointAttribs.call(this,t,e);return delete o.fill,o}toYData(t){return[t.high,t.low,t.close]}translate(){const i=this,r=i.yAxis,t=this.pointArrayMap&&this.pointArrayMap.slice()||[],n=t.map(t=>"plot"+(t.charAt(0).toUpperCase()+t.slice(1)));n.push("yBottom"),t.push("low"),super.translate.apply(i),i.points.forEach(function(s){t.forEach(function(t,e){let o=s[t];null!==o&&(i.dataModify&&(o=i.dataModify.modifyValue(o)),s[n[e]]=r.toPixels(o,!0))}),s.tooltipPos[1]=s.plotHigh+r.pos-i.chart.plotTop})}}HLCSeries.defaultOptions=merge(ColumnSeries.defaultOptions,HLCSeriesDefaults),extend(HLCSeries.prototype,{pointClass:HLCPoint,animate:null,directTouch:!1,pointArrayMap:["high","low","close"],pointAttrToOptions:{stroke:"color","stroke-width":"lineWidth"},pointValKey:"close"}),SeriesRegistry.registerSeriesType("hlc",HLCSeries);export default HLCSeries;