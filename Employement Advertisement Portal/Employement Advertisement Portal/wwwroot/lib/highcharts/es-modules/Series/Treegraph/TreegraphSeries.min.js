"use strict";import PU from"../PathUtilities.js";const getLinkPath=PU["getLinkPath"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{treemap:TreemapSeries,column:ColumnSeries}}=SeriesRegistry;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";const{symbols}=SVGRenderer["prototype"];import TreegraphNode from"./TreegraphNode.js";import TreegraphPoint from"./TreegraphPoint.js";import TU from"../TreeUtilities.js";const{getLevelOptions,getNodeWidth}=TU;import U from"../../Core/Utilities.js";const{arrayMax,extend,merge,pick,relativeLength,splat}=U;import TreegraphLink from"./TreegraphLink.js";import TreegraphLayout from"./TreegraphLayout.js";import TreegraphSeriesDefaults from"./TreegraphSeriesDefaults.js";class TreegraphSeries extends TreemapSeries{constructor(){super(...arguments),this.nodeList=[],this.links=[]}init(){super.init.apply(this,arguments),this.layoutAlgorythm=new TreegraphLayout}getLayoutModifiers(){const e=this.chart,h=this,d=e.plotSizeX,g=e.plotSizeY,c=arrayMax(this.points.map(e=>e.node.xPosition));let k=1/0,m=-1/0,y=1/0,T=-1/0,v=0,u=0,P=0,L=0;this.points.forEach(t=>{if(!this.options.fillSpace||t.visible){const i=t.node,s=h.mapOptionsToLevel[t.node.level]||{},o=merge(this.options.marker,s.marker,t.options.marker),r=o.width??getNodeWidth(this,c),a=relativeLength(o.radius||0,Math.min(d,g)),l=o.symbol,n="circle"!==l&&o.height?relativeLength(o.height,g):2*a,p="circle"!==l&&r?relativeLength(r,d):2*a;i.nodeSizeX=p,i.nodeSizeY=n;let e;i.xPosition<=k&&(k=i.xPosition,e=o.lineWidth||0,u=Math.max(p+e,u)),i.xPosition>=m&&(m=i.xPosition,e=o.lineWidth||0,v=Math.max(p+e,v)),i.yPosition<=y&&(y=i.yPosition,e=o.lineWidth||0,L=Math.max(n+e,L)),i.yPosition>=T&&(T=i.yPosition,e=o.lineWidth||0,P=Math.max(n+e,P))}});var t=T===y?1:(g-(L+P)/2)/(T-y),i=T===y?g/2:-t*y+L/2,s=m===k?1:(d-(v+v)/2)/(m-k);return{ax:s,bx:m===k?d/2:-s*k+u/2,ay:t,by:i}}getLinks(){const i=this,s=[];return this.data.forEach(e=>{var t=i.mapOptionsToLevel[e.node.level||0]||{};e.node.parent?(t=merge(t,e.options),!e.linkToParent||e.linkToParent.destroyed?(t=new i.LinkClass(i,t,void 0,e),e.linkToParent=t):(e.collapsed=pick(e.collapsed,(this.mapOptionsToLevel[e.node.level]||{}).collapsed),e.linkToParent.visible=e.linkToParent.toNode.visible),e.linkToParent.index=s.push(e.linkToParent)-1):e.linkToParent&&(i.links.splice(e.linkToParent.index),e.linkToParent.destroy(),delete e.linkToParent)}),s}buildTree(e,t,i,s,o){var r=this.points[t];return i=r&&r.level||i,super.buildTree.call(this,e,t,i,s,o)}markerAttribs(){return{}}setCollapsedStatus(e,t){const i=e.point;i&&(i.collapsed=pick(i.collapsed,(this.mapOptionsToLevel[e.level]||{}).collapsed),t=!1!==(i.visible=t)&&!i.collapsed),e.children.forEach(e=>{this.setCollapsedStatus(e,t)})}drawTracker(){ColumnSeries.prototype.drawTracker.apply(this,arguments),ColumnSeries.prototype.drawTracker.call(this,this.links)}translate(){var e=this,t=e.options;let i=TU.updateRootId(e),s;seriesProto.translate.call(e);var o=e.tree=e.getTree();s=e.nodeMap[i],""===i||s&&s.children.length||(e.setRootNode("",!1),i=e.rootNode,s=e.nodeMap[i]),e.mapOptionsToLevel=getLevelOptions({from:s.level+1,levels:t.levels,to:o.height,defaults:{levelIsConstant:e.options.levelIsConstant,colorByPoint:t.colorByPoint}}),this.setCollapsedStatus(o,!0),e.links=e.getLinks(),e.setTreeValues(o),this.layoutAlgorythm.calculatePositions(e),e.layoutModifier=this.getLayoutModifiers(),this.points.forEach(e=>{this.translateNode(e)}),this.points.forEach(e=>{e.linkToParent&&this.translateLink(e.linkToParent)}),t.colorByPoint||e.setColorRecursive(e.tree)}translateLink(i){var s=i.fromNode,o=i.toNode,r=this.options.link.lineWidth,a=Math.round(r)%2/2,l=pick(this.options.link.curveFactor,.5),n=pick(i.options.link&&i.options.link.type,this.options.link.type);if(s.shapeArgs&&o.shapeArgs){var p=s.shapeArgs.width||0,h=this.chart.inverted,d=Math.floor((s.shapeArgs.y||0)+(s.shapeArgs.height||0)/2)+a,g=Math.floor((o.shapeArgs.y||0)+(o.shapeArgs.height||0)/2)+a;let e=Math.floor((s.shapeArgs.x||0)+p)+a,t=Math.floor(o.shapeArgs.x||0)+a;h&&(e-=p,t+=o.shapeArgs.width||0);var s=o.node.xPosition-s.node.xPosition,c=(i.shapeType="path",Math.abs(t-e)+p),c=c/s-p,s=c*l*(h?-1:1),p=Math.floor((t+e)/2)+a;i.plotX=p,i.plotY=g,i.shapeArgs={d:getLinkPath[n]({x1:e,y1:d,x2:t,y2:g,width:c,offset:s,inverted:h,parentVisible:o.visible,radius:this.options.link.radius})},i.dlBox={x:(e+t)/2,y:(d+g)/2,height:r,width:0},i.tooltipPos=h?[(this.chart.plotSizeY||0)-i.dlBox.y,(this.chart.plotSizeX||0)-i.dlBox.x]:[i.dlBox.x,i.dlBox.y]}}drawNodeLabels(e){var t=this.mapOptionsToLevel;let i,s;for(const o of e)s=t[o.node.level],i={style:{}},s&&s.dataLabels&&(i=merge(i,s.dataLabels),this.hasDataLabels=()=>!0),o.shapeArgs&&!splat(this.options.dataLabels)[0].style.width&&(i.style.width=o.shapeArgs.width,o.dataLabel&&o.dataLabel.css({width:o.shapeArgs.width+"px"})),o.dlOptions=merge(i,o.options.dataLabels);seriesProto.drawDataLabels.call(this,e)}alignDataLabel(e,t){const i=e.visible;e.visible=!0,super.alignDataLabel.apply(this,arguments),t.animate({opacity:!1===i?0:1},void 0,function(){i||t.hide()}),e.visible=i}drawDataLabels(){this.options.dataLabels&&(this.options.dataLabels=splat(this.options.dataLabels),this.drawNodeLabels(this.points),seriesProto.drawDataLabels.call(this,this.links))}destroy(){if(this.links){for(const e of this.links)e.destroy();this.links.length=0}return seriesProto.destroy.apply(this,arguments)}pointAttribs(e,t){var i=this,s=e&&i.mapOptionsToLevel[e.node.level||0]||{},o=e&&e.options,r=s.states&&s.states[t]||{};e&&(e.options.marker=merge(i.options.marker,s.marker,e.options.marker));const a=pick(r&&r.link&&r.link.color,o&&o.link&&o.link.color,s&&s.link&&s.link.color,i.options.link&&i.options.link.color),l=pick(r&&r.link&&r.link.lineWidth,o&&o.link&&o.link.lineWidth,s&&s.link&&s.link.lineWidth,i.options.link&&i.options.link.lineWidth),n=seriesProto.pointAttribs.call(i,e,t);return e&&(e.isLink&&(n.stroke=a,n["stroke-width"]=l,delete n.fill),e.visible||(n.opacity=0)),n}drawPoints(){TreemapSeries.prototype.drawPoints.apply(this,arguments),ColumnSeries.prototype.drawPoints.call(this,this.links)}translateNode(e){const t=this.chart,i=e.node,s=t.plotSizeY,o=t.plotSizeX,{ax:r,bx:a,ay:l,by:n}=this.layoutModifier,p=r*i.xPosition+a,h=l*i.yPosition+n,d=this.mapOptionsToLevel[i.level]||{},g=merge(this.options.marker,d.marker,e.options.marker),c=g.symbol,k=i.nodeSizeY,m=i.nodeSizeX,y=this.options.reversed,T=i.x=t.inverted?o-m/2-p:p-m/2,v=i.y=y?h-k/2:s-h-k/2,u=pick(e.options.borderRadius,d.borderRadius,this.options.borderRadius),P=symbols[c||"circle"];if(void 0===P?(e.hasImage=!0,e.shapeType="image",e.imageUrl=c.match(/^url\((.*?)\)$/)[1]):e.shapeType="path",!e.visible&&e.linkToParent){var L=e.linkToParent.fromNode;if(L){const f=L.shapeArgs||{},{x:p=0,y:h=0,width:m=0,height:k=0}=f;e.shapeArgs||(e.shapeArgs={}),e.hasImage||extend(e.shapeArgs,{d:P(p,h,m,k,u?{r:u}:void 0)}),extend(e.shapeArgs,{x:p,y:h}),e.plotX=L.plotX,e.plotY=L.plotY}}else e.plotX=T,e.plotY=v,e.shapeArgs={x:T,y:v,width:m,height:k,cursor:e.node.isLeaf?"default":"pointer"},e.hasImage||(e.shapeArgs.d=P(T,v,m,k,u?{r:u}:void 0));e.tooltipPos=t.inverted?[s-v-k/2,o-T-m/2]:[T+m/2,v]}}TreegraphSeries.defaultOptions=merge(TreemapSeries.defaultOptions,TreegraphSeriesDefaults),extend(TreegraphSeries.prototype,{pointClass:TreegraphPoint,NodeClass:TreegraphNode,LinkClass:TreegraphLink}),SeriesRegistry.registerSeriesType("treegraph",TreegraphSeries);export default TreegraphSeries;