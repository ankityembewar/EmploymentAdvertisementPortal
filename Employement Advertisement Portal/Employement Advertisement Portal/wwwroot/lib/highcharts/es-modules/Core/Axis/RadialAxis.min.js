"use strict";import D from"../Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../Globals.js";const{composed,noop}=H;import U from"../Utilities.js";const{addEvent,correctFloat,defined,extend,fireEvent,isObject,merge,pick,pushUnique,relativeLength,wrap}=U;var RadialAxis;!function(t){const r={gridLineWidth:1,labels:{align:void 0,x:0,y:void 0,style:{textOverflow:"none"}},maxPadding:0,minPadding:0,showLastLabel:!1,tickLength:0},h={endOnTick:!1,gridLineWidth:0,labels:{align:"center",distance:-25,x:0,y:void 0},lineWidth:1,minorGridLineWidth:0,minorTickInterval:"auto",minorTickLength:10,minorTickPosition:"inside",minorTickWidth:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickPosition:"inside",tickWidth:2,title:{rotation:0,text:""},zIndex:2},l={gridLineInterpolation:"circle",gridLineWidth:1,labels:{align:"right",x:-3,y:-2},showLastLabel:!1,title:{x:4,text:null,rotation:90}};function i(){this.autoConnect=this.isCircular&&void 0===pick(this.userMax,this.options.max)&&correctFloat(this.endAngleRad-this.startAngleRad)===correctFloat(2*Math.PI),!this.isCircular&&this.chart.inverted&&this.max++,this.autoConnect&&(this.max+=(this.categories?1:this.pointRange)||this.closestPointRange||0)}function e(){return()=>{if(this.isRadial&&this.tickPositions&&this.options.labels&&!0!==this.options.labels.allowOverlap)return this.tickPositions.map(t=>this.ticks[t]&&this.ticks[t].label).filter(t=>Boolean(t))}}function c(){return noop}function s(t,i,e){var s=this.pane.center;let n=t.value,a,o,r;return this.isCircular?(defined(n)?t.point&&(t.point.shapeArgs||{}).start&&(n=this.chart.inverted?this.translate(t.point.rectPlotY,!0):t.point.x):(o=t.chartX||0,r=t.chartY||0,n=this.translate(Math.atan2(r-e,o-i)-this.startAngleRad,!0)),a=this.getPosition(n),o=a.x,r=a.y):(defined(n)||(o=t.chartX,r=t.chartY),defined(o)&&defined(r)&&(e=s[1]+this.chart.plotTop,n=this.translate(Math.min(Math.sqrt(Math.pow(o-i,2)+Math.pow(r-e,2)),s[2]/2)-s[3]/2,!0))),[n,o||0,r||0]}function n(t,i,e){var s=this.pane.center,n=this.chart,a=this.left||0,o=this.top||0;let r,h=pick(i,s[2]/2-this.offset),l;return(e=void 0===e?this.horiz?0:this.center&&-this.center[3]/2:e)&&(h+=e),this.isCircular||void 0!==i?((l=this.chart.renderer.symbols.arc(a+s[0],o+s[1],h,h,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0})).xBounds=[a+s[0]],l.yBounds=[o+s[1]-h]):(r=this.postTranslate(this.angleRad,h),l=[["M",this.center[0]+n.plotLeft,this.center[1]+n.plotTop],["L",r.x,r.y]]),l}function a(){const t=this.constructor.prototype;t.getOffset.call(this),this.chart.axisOffset[this.side]=0}function o(t,i,e){const s=this.chart,n=i=>{if("string"!=typeof i)return i;{let t=parseInt(i,10);return t=d.test(i)?t*r/100:t}},a=this.center,o=this.startAngleRad,r=a[2]/2,h=Math.min(this.offset,0),l=this.left||0,c=this.top||0,d=/%$/,p=this.isCircular;let g,u,f,x,P,A,v=pick(n(e.outerRadius),r),m=n(e.innerRadius),R=pick(n(e.thickness),10);return"polygon"===this.options.gridLineInterpolation?A=this.getPlotLinePath({value:t}).concat(this.getPlotLinePath({value:i,reverse:!0})):(t=Math.max(t,this.min),i=Math.min(i,this.max),t=this.translate(t),i=this.translate(i),p||(v=t||0,m=i||0),"circle"!==e.shape&&p?(g=o+(t||0),u=o+(i||0)):(g=-Math.PI/2,u=1.5*Math.PI,P=!0),v-=h,R-=h,A=s.renderer.symbols.arc(l+a[0],c+a[1],v,v,{start:Math.min(g,u),end:Math.max(g,u),innerR:pick(m,v-R),open:P}),p&&(f=(u+g)/2,x=l+a[0]+a[2]/2*Math.cos(f),A.xBounds=f>-Math.PI/2&&f<Math.PI/2?[x,s.plotWidth]:[0,x],A.yBounds=[c+a[1]+a[2]/2*Math.sin(f)],A.yBounds[0]+=f>-Math.PI&&f<0||f>Math.PI?-10:10)),A}function d(t){const i=this.pane.center,e=this.chart,s=e.inverted,n=t.reverse,a=this.pane.options.background?this.pane.options.background[0]||this.pane.options.background:{},o=a.innerRadius||"0%",r=a.outerRadius||"100%",h=i[0]+e.plotLeft,l=i[1]+e.plotTop,c=this.height,d=t.isCrosshair,p=i[3]/2;let g=t.value,u,f,x,P,A,v,m,R,k;var M=this.getPosition(g);let y=M.x,L=M.y;if(d&&(R=this.getCrosshairPosition(t,h,l),g=R[0],y=R[1],L=R[2]),this.isCircular)f=Math.sqrt(Math.pow(y-h,2)+Math.pow(L-l,2)),x="string"==typeof o?relativeLength(o,1):o/f,P="string"==typeof r?relativeLength(r,1):r/f,i&&p&&(u=p/f,x<u&&(x=u),P<u&&(P=u)),k=[["M",h+x*(y-h),l-x*(l-L)],["L",y-(1-P)*(y-h),L+(1-P)*(l-L)]];else if((g=this.translate(g))&&(g<0||g>c)&&(g=0),"circle"===this.options.gridLineInterpolation)k=this.getLinePath(0,g,p);else if(k=[],e[s?"yAxis":"xAxis"].forEach(t=>{t.pane===this.pane&&(A=t)}),A){m=A.tickPositions,A.autoConnect&&(m=m.concat([m[0]])),n&&(m=m.slice().reverse()),g&&(g+=p);for(let t=0;t<m.length;t++)v=A.getPosition(m[t],g),k.push(t?["L",v.x,v.y]:["M",v.x,v.y])}return k}function p(t,i){t=this.translate(t);return this.postTranslate(this.isCircular?t:this.angleRad,pick(this.isCircular?i:t<0?0:t,this.center[2]/2)-this.offset)}function g(){var t=this.center,i=this.chart,e=this.options.title;return{x:i.plotLeft+t[0]+(e.x||0),y:i.plotTop+t[1]-{high:.5,middle:.25,low:0}[e.align]*t[2]+(e.y||0)}}function u(t){t.beforeSetTickPositions=i,t.createLabelCollector=e,t.getCrosshairPosition=s,t.getLinePath=n,t.getOffset=a,t.getPlotBandPath=o,t.getPlotLinePath=d,t.getPosition=p,t.getTitlePosition=g,t.postTranslate=k,t.setAxisSize=y,t.setAxisTranslation=L,t.setOptions=b}function f(){var e=this.chart,s=this.options,n=e.angular&&this.isXAxis,a=this.pane,o=a&&a.options;if(!n&&a&&(e.angular||e.polar)){n=2*Math.PI,a=(pick(o.startAngle,0)-90)*Math.PI/180,e=(pick(o.endAngle,pick(o.startAngle,0)+360)-90)*Math.PI/180;this.angleRad=(s.angle||0)*Math.PI/180,this.startAngleRad=a,this.endAngleRad=e,this.offset=s.offset||0;let t=(a%n+n)%n,i=(e%n+n)%n;t>Math.PI&&(t-=n),i>Math.PI&&(i-=n),this.normalizedStartAngleRad=t,this.normalizedEndAngleRad=i}}function x(t){this.isRadial&&(t.align=void 0,t.preventDefault())}function P(){var t;this.chart&&this.chart.labelCollectors&&(0<=(t=this.labelCollector?this.chart.labelCollectors.indexOf(this.labelCollector):-1)&&this.chart.labelCollectors.splice(t,1))}function A(t){const i=this.chart,e=i.angular,s=i.polar,n=this.isXAxis,a=this.coll,o=e&&n,r=t.userOptions.pane||0,h=this.pane=i.pane&&i.pane[r];let l;"colorAxis"===a?this.isRadial=!1:(e?(o?((t=this).isHidden=!0,t.createLabelCollector=c,t.getOffset=noop,t.redraw=M,t.render=M,t.setScale=noop,t.setCategories=noop,t.setTitle=noop):u(this),l=!n):s&&(u(this),l=this.horiz),e||s?(this.isRadial=!0,this.labelCollector||(this.labelCollector=this.createLabelCollector()),this.labelCollector&&i.labelCollectors.push(this.labelCollector)):this.isRadial=!1,h&&l&&(h.axis=this),this.isCircular=l)}function v(){this.isRadial&&this.beforeSetTickPositions()}function m(l){const c=this.label;if(c){const d=this.axis,p=c.getBBox(),g=d.options.labels,u=(d.translate(this.pos)+d.startAngleRad+Math.PI/2)/Math.PI*180%360,f=Math.round(u),x=defined(g.y)?0:.3*-p.height;let t=g.y,i,e=20,s=g.align,n="end",a=f<0?f+360:f,o=a,r=0,h=0;d.isRadial&&(i=d.getPosition(this.pos,d.center[2]/2+relativeLength(pick(g.distance,-25),d.center[2]/2,-d.center[2]/2)),"auto"===g.rotation?c.attr({rotation:u}):defined(t)||(t=d.chart.renderer.fontMetrics(c).b-p.height/2),defined(s)||(s=d.isCircular?u>(e=p.width>d.len*d.tickInterval/(d.max-d.min)?0:e)&&u<180-e?"left":u>180+e&&u<360-e?"right":"center":"center",c.attr({align:s})),"auto"===s&&2===d.tickPositions.length&&d.isCircular&&(90<a&&a<180?a=180-a:270<a&&a<=360&&(a=540-a),180<o&&o<=360&&(o=360-o),d.pane.options.startAngle!==f&&d.pane.options.startAngle!==f+360&&d.pane.options.startAngle!==f-360||(n="start"),s=-90<=f&&f<=90||-360<=f&&f<=-270||270<=f&&f<=360?"start"===n?"right":"left":"start"===n?"left":"right",70<o&&o<110&&(s="center"),a<15||180<=a&&a<195?r=.3*p.height:15<=a&&a<=35?r="start"===n?0:.75*p.height:195<=a&&a<=215?r="start"===n?.75*p.height:0:35<a&&a<=90?r="start"===n?.25*-p.height:p.height:215<a&&a<=270&&(r="start"===n?p.height:.25*-p.height),o<15?h="start"===n?.15*-p.height:.15*p.height:165<o&&o<=180&&(h="start"===n?.15*p.height:.15*-p.height),c.attr({align:s}),c.translate(h,r+x)),l.pos.x=i.x+(g.x||0),l.pos.y=i.y+(t||0))}}function R(t){this.axis.getPosition&&extend(t.pos,this.axis.getPosition(this.pos))}function k(t,i){var e=this.chart,s=this.center;return t=this.startAngleRad+t,{x:e.plotLeft+s[0]+Math.cos(t)*i,y:e.plotTop+s[1]+Math.sin(t)*i}}function M(){this.isDirty=!1}function y(){const t=this.constructor.prototype;let i,e;t.setAxisSize.call(this),this.isRadial&&(this.pane.updateCenter(this),i=this.center=this.pane.center.slice(),this.isCircular?this.sector=this.endAngleRad-this.startAngleRad:(e=this.postTranslate(this.angleRad,i[3]/2),i[0]=e.x-this.chart.plotLeft,i[1]=e.y-this.chart.plotTop),this.len=this.width=this.height=(i[2]-i[3])*pick(this.sector,1)/2)}function L(){const t=this.constructor.prototype;t.setAxisTranslation.call(this),this.center&&(this.isCircular?this.transA=(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.transA=(this.center[2]-this.center[3])/2/(this.max-this.min||1),this.isXAxis?this.minPixelPadding=this.transA*this.minPointOffset:this.minPixelPadding=0)}function b(t){var i=this["coll"],{angular:e,inverted:s,polar:n}=this.chart;let a={};e?this.isXAxis||(a=merge(defaultOptions.yAxis,h)):n&&(a=this.horiz?merge(defaultOptions.xAxis,r):merge("xAxis"===i?defaultOptions.xAxis:defaultOptions.yAxis,l)),s&&"yAxis"===i&&(a.stackLabels=isObject(defaultOptions.yAxis,!0)?defaultOptions.yAxis.stackLabels:{},a.reversedStacks=!0);const o=this.options=merge(a,t);o.plotBands||(o.plotBands=[]),fireEvent(this,"afterSetOptions")}function C(t,i,e,s,n,a,o){const r=this.axis;let h,l;return l=r.isRadial?["M",i,e,"L",(h=r.getPosition(this.pos,r.center[2]/2+s)).x,h.y]:t.call(this,i,e,s,n,a,o)}t.compose=function(t,i){return pushUnique(composed,"Axis.Radial")&&(addEvent(t,"afterInit",f),addEvent(t,"autoLabelAlign",x),addEvent(t,"destroy",P),addEvent(t,"init",A),addEvent(t,"initialAxisTranslation",v),addEvent(i,"afterGetLabelPosition",m),addEvent(i,"afterGetPosition",R),wrap(i.prototype,"getMarkPath",C)),t}}(RadialAxis=RadialAxis||{});export default RadialAxis;