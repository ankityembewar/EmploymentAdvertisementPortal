"use strict";import D from"../../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../../Core/Globals.js";const composed=H["composed"];import RangeSelectorDefaults from"./RangeSelectorDefaults.js";import U from"../../Core/Utilities.js";const{addEvent,defined,extend,find,isNumber,merge,pick,pushUnique}=U,chartDestroyEvents=[];let RangeSelectorConstructor;function axisMinFromRange(){function t(t,e){var o="year"===a?"FullYear":"Month";const r=new i.Date(t);var n=i.get(o,r);return i.set(o,r,n+e),n===i.get(o,r)&&i.set("Date",r,0),r.getTime()-t}const e=this.range,a=e.type,o=this.max,i=this.chart.time;let r,n;isNumber(e)?(r=o-e,n=e):e&&(r=o+t(o,-(e.count||1)),this.chart&&this.chart.setFixedRange(o-r));var s=pick(this.dataMin,Number.MIN_VALUE);return(r=isNumber(r)?r:s)<=s&&(r=s,void 0===n&&(n=t(r,e.count)),this.newMax=Math.min(r+n,pick(this.dataMax,Number.MAX_VALUE))),isNumber(o)?!isNumber(e)&&e&&e._offsetMin&&(r+=e._offsetMin):r=void 0,r}function compose(t,e,o){if(RangeSelectorConstructor=o,pushUnique(composed,"RangeSelector")){const r=e.prototype;t.prototype.minFromRange=axisMinFromRange,addEvent(e,"afterGetContainer",onChartAfterGetContainer),addEvent(e,"beforeRender",onChartBeforeRender),addEvent(e,"destroy",onChartDestroy),addEvent(e,"getMargins",onChartGetMargins),addEvent(e,"render",onChartRender),addEvent(e,"update",onChartUpdate),r.callbacks.push(onChartCallback),extend(defaultOptions,{rangeSelector:RangeSelectorDefaults.rangeSelector}),extend(defaultOptions.lang,RangeSelectorDefaults.lang)}}function onChartAfterGetContainer(){this.options.rangeSelector&&this.options.rangeSelector.enabled&&(this.rangeSelector=new RangeSelectorConstructor(this))}function onChartBeforeRender(){const t=this,e=t.axes,o=t.rangeSelector;var r;o&&(isNumber(o.deferredYTDClick)&&(o.clickButton(o.deferredYTDClick),delete o.deferredYTDClick),e.forEach(t=>{t.updateNames(),t.setScale()}),t.getAxisMargins(),o.render(),r=o.options.verticalAlign,o.options.floating||("bottom"===r?this.extraBottomMargin=!0:"middle"!==r&&(this.extraTopMargin=!0)))}function onChartCallback(e){let t,o,r,n;const a=e.rangeSelector,i=()=>{a&&(t=e.xAxis[0].getExtremes(),o=e.legend,n=a&&a.options.verticalAlign,isNumber(t.min)&&a.render(t.min,t.max),o.display&&"top"===n&&n===o.options.verticalAlign&&(r=merge(e.spacingBox),"vertical"===o.options.layout?r.y=e.plotTop:r.y+=a.getHeight(),o.group.placed=!1,o.align(r)))};a&&(find(chartDestroyEvents,t=>t[0]===e)||chartDestroyEvents.push([e,[addEvent(e.xAxis[0],"afterSetExtremes",function(t){a&&a.render(t.min,t.max)}),addEvent(e,"redraw",i)]]),i())}function onChartDestroy(){for(let t=0,e=chartDestroyEvents.length;t<e;++t){const o=chartDestroyEvents[t];if(o[0]===this)return o[1].forEach(t=>t()),void chartDestroyEvents.splice(t,1)}}function onChartGetMargins(){const t=this.rangeSelector;var e;t&&(e=t.getHeight(),this.extraTopMargin&&(this.plotTop+=e),this.extraBottomMargin&&(this.marginBottom+=e))}function onChartRender(){const t=this.rangeSelector;var e;t&&!t.options.floating&&(t.render(),"bottom"===(e=t.options.verticalAlign)?this.extraBottomMargin=!0:"middle"!==e&&(this.extraTopMargin=!0))}function onChartUpdate(t){var t=t.options.rangeSelector,e=this.extraBottomMargin,o=this.extraTopMargin;let r=this.rangeSelector;t&&t.enabled&&!defined(r)&&this.options.rangeSelector&&(this.options.rangeSelector.enabled=!0,this.rangeSelector=r=new RangeSelectorConstructor(this)),this.extraBottomMargin=!1,this.extraTopMargin=!1,r&&(onChartCallback(this),t=t&&t.verticalAlign||r.options&&r.options.verticalAlign,r.options.floating||("bottom"===t?this.extraBottomMargin=!0:"middle"!==t&&(this.extraTopMargin=!0)),this.extraBottomMargin===e&&this.extraTopMargin===o||(this.isDirtyBox=!0))}const RangeSelectorComposition={compose:compose};export default RangeSelectorComposition;